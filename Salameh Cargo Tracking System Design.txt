Salameh Cargo Tracking System Design
Overview
This document outlines the design for a custom cargo shipment tracking system for Salameh Cargo. The system is built with raw PHP (backend), HTML/CSS/JavaScript (frontend) without frameworks, and uses a MySQL database on XAMPP. The goal is a responsive, futuristic UI that allows clients to track shipments and an admin panel for managing data. All components are designed to be bulletproof and restartable from scratch, meaning the system can be initialized and run independently with the provided specifications.
Key features include:
- A public-facing client portal (Home, Track Shipment, About, Contact, Login, Dashboard) with an emphasis on sleek, modern design and mobile responsiveness.
- A secure Admin Panel for managing users, shipments, and automating tracking updates via web scraping of external shipping websites.
- WhatsApp-based OTP login for clients (passwordless authentication via one-time code sent to the user’s WhatsApp).
- Automated tracking integration with external cargo tracking sources, storing results in the database and falling back to stored data if live fetch fails.
Public Website (Client Portal)
The public-facing site consists of several pages that provide information and functionality to clients. All pages feature a consistent futuristic theme (e.g. clean typography, modern color scheme, possibly a dark background with vibrant accents) and a responsive layout that adapts to mobile, tablet, and desktop screens. A common header navigation bar is present on all public pages (except maybe the standalone login page) with links to Home, Track, About, Contact, and Login. The design should prioritize simplicity and ease of use, with intuitive UI elements and quick load times.
Home Page
* Purpose: Welcome page with branding and quick access to tracking. It should impress users with a modern look while remaining clear and functional.
* Layout & Content: A prominent, centrally-placed shipment tracking search bar on the home page allows users to input a tracking number or other identifier right away. This acts as a quick search field (functionally similar to the dedicated Track page search).
* The header includes the company logo and navigation menu.
* The main hero section could feature a background image or graphic related to cargo/logistics (e.g., a world map, shipping containers, or futuristic digital globe) to enhance the futuristic feel.
* Below the search bar, there may be a brief tagline or overview of Salameh Cargo’s services. For example, “Fast, Reliable Cargo Shipping – Track your shipment in real time.”
* Responsive Design: On mobile devices, the navigation collapses into a burger menu. The search bar and content scale appropriately (e.g., the search bar becomes a large input field on small screens, still prominently visible without side scrolling).
* Interactivity: The search bar can simply submit to the Track page or perform an AJAX search. (Optional enhancement: a slight animation or highlight on the search bar on focus to guide the user, consistent with a high-tech aesthetic.)
Track Your Shipment Page
* Purpose: Allows users (without logging in) to track a shipment by entering an identifier. It serves both as a general tracking lookup and as a fallback for anyone who doesn’t have an account.
* Search Functionality: A single search input field where the user can enter any of the following: tracking number, associated phone number, full name of receiver, or a shipment code. On submission, the system will search the database for shipments matching that input.
* The search is flexible: for example, if a phone number or name is entered, it may return all shipments associated with that phone/name. If a specific tracking number or unique shipment code is entered, it should return the exact match.
* If multiple shipments match (e.g., searching by name or phone yields several records), the page displays a results table listing all matching shipments with key details (tracking number, origin/destination, status, etc.), allowing the user to identify the correct one. Each result can have a “View Details” link to see full shipment info.
* If a unique shipment is found (e.g., exact tracking number), the page can directly show the shipment details (status, dates, etc.).
* Data Source: By default, results are fetched from the local database (which is regularly updated via admin input or automated scrapes). If the shipment is not found locally or if live status is needed, the system can fetch live tracking info from external websites as a secondary step (see Automated Tracking Integration in Admin Panel for details). For example, if a user enters a container number not yet in the database, the system could query an external API or site like track-trace or the relevant shipping line site, then display the info.
* The interface should indicate if the data is live-fetched or from the database (e.g., “Last updated 2 hours ago” or “Fetched live from CMA CGM”). This assures the user the information is current.
* If external fetch fails or is unavailable, show the last known status from the database (fallback) with a note like “Showing last updated status from database.”
* UI Design: The page should have a clean form with the search input and a Search button. Instructions or placeholder text should guide the user (e.g., “Enter Tracking #, Phone, Name, or Code”). Use subtle futuristic styling (for instance, glowing border on input focus).
* Below the search bar (and results once displayed), ensure there is space for messages or tips (e.g., “Tip: You can find your tracking number on your receipt or via our confirmation SMS/Email.”).
* Results Display: If showing a list, use a table or card layout. Each result might show: Tracking Number, Recipient Name, Origin -> Destination, Status (with perhaps a colored badge, e.g., green for delivered, orange for in-transit), and possibly Last Updated timestamp.
* If a single result, show a detailed view: including all available fields (status history, current status, shipment dates, etc.). The design should highlight the current status prominently (maybe at the top of the detail view, e.g., “STATUS: En Route” in large text).
* Optionally, include a small map or icon indicating transit if such data is available (not required, but could be a future enhancement for a more “futuristic” feel).
* Responsive Behavior: On smaller screens, if a results table is used, make it scrollable or stack fields so it remains readable. The search input should be full-width on mobile.
About Us Page
* Purpose: Provide information about Salameh Cargo (history, mission, services, etc.). This is a static content page.
* Content: This will contain text, images, or videos describing the company. It might include sections like “Who We Are,” “Our Mission,” “Our Services,” and possibly highlights like customer testimonials or partner logos.
* Design: Even though it’s static, maintain the modern aesthetic. Use headings and short paragraphs for readability (for example, a section with a heading “Our Mission” followed by 3-4 sentence paragraph). Include relevant images (e.g., warehouse, team, trucks) if available to make the page engaging.
* Editability: Since no CMS framework is used, content will be edited in HTML/PHP files directly. (Optionally, developers could create a simple PHP include for this content or even a tiny admin interface to edit it, but that’s not a requirement here.)
Contact Us Page
* Purpose: Let users reach out or find contact information.
* Content: Provide the company’s contact details (phone number, email, physical address, working hours). Instead of a traditional contact form (which would require backend email handling), the main interactive element is a WhatsApp chat link/button.
* WhatsApp Chat Integration: A prominent button or link labeled like “Chat with us on WhatsApp” will open WhatsApp (web or app) with a pre-filled chat to Salameh Cargo’s number. This can be achieved using a WhatsApp URL (for example: https://wa.me/<CompanyPhoneNumber>?text=Hello%20Salameh%20Cargo%2C%20I%20need%20assistance%20with...). This allows customers to immediately start a WhatsApp conversation for support or inquiries.
* Design: The page can show a WhatsApp icon next to the chat button for clarity. Other contact methods (phone/email) can be shown as icons or simple text. Keep the layout simple: perhaps a two-column on desktop (one side with a contact form placeholder or map, other side with info), and stacked on mobile.
* Additional Info: Optionally embed a Google Map showing the office location (to enhance credibility and modern feel). Ensure any embedded map or external content is responsive.
* No Captcha/Forms: Since we are focusing on WhatsApp for inquiries, there’s no contact form with captcha needed (keeping it simpler and aligning with the WhatsApp-based communication approach that the client favors).
Login Page (User Login via OTP)
* Purpose: Allow clients to log in to view their personal shipment dashboard. The login uses phone number authentication with a WhatsApp OTP (one-time passcode) instead of a traditional username/password. This provides quick, passwordless access and ties the login to their phone (which is likely already known to Salameh Cargo).
* Login Form: The form should ask for the user’s phone number (in international format if applicable). Optionally, to avoid misuse, you might include a simple numeric captcha or rate-limit requests, but since it’s OTP-based, the main security is possession of the phone.
* When the user submits their phone number, the system verifies if this phone exists in the users database table. If the phone is registered (i.e., matches a client record), the system will generate a random 6-digit OTP code.
* WhatsApp OTP Send: Using an integration (such as Twilio’s WhatsApp API or WhatsApp Business Cloud API), send a WhatsApp message to the user’s number containing the OTP code. The message can be branded (e.g., “Your Salameh Cargo login code is 123456. It will expire in 5 minutes."). Note: This requires a backend integration with WhatsApp – e.g., Twilio Verify API for WhatsApp can handle sending OTP templates[1].
* After sending, the page should prompt the user to enter the OTP that they received. This can be on the same page (dynamically via JS: first input phone, then reveal OTP field) or by redirecting to an “Enter OTP” page. For simplicity, it could be done in one page using JavaScript to swap the form view.
* OTP Verification: When the user inputs the code, the system checks if it matches the code sent (which should be stored securely server-side, e.g., in a _SESSION or a temp database table, along with an expiration timestamp). If correct and not expired (e.g., valid for 5-10 minutes), the user is authenticated.
* On success, create a login session (e.g., $_SESSION['user_id'] = ...) and redirect to the User Dashboard.
* If the OTP is wrong or expired, show an error and allow retry (possibly allow requesting a new code if needed, with some limit to prevent abuse).
* Security Considerations:
* Ensure the OTP is random and not easily guessable (6 digit numerical or alphanumeric code).
* It should expire after a short time.
* Each phone number request could invalidate any previous code to avoid confusion.
* Use server-side session or secure storage for OTP; do not expose it to the client except via the WhatsApp message.
* The phone number field should be sanitized and validated (only allow digits, plus sign, etc., to match real phone formats, to avoid SQL injection or wrong number formats).
* UX: The login page should be simple and clear. On mobile, since the user likely will switch to WhatsApp to get the code, consider making the OTP input easy to refocus when they return (maybe using an HTML5 <input type="number" pattern="\d*"> for mobile numeric keypad). Provide feedback like “OTP sent to your WhatsApp - please check your messages.”
* Fallback: In case WhatsApp OTP cannot be delivered (e.g., user’s WhatsApp not reachable), consider allowing an alternative like SMS OTP. However, this is beyond the scope unless explicitly required; by default, only WhatsApp is used as per requirements.
User Dashboard (My Shipments)
* Purpose: Once logged in, a user can view all shipments associated with their phone number/account. This dashboard is restricted to the logged-in user’s data (ensured by linking shipments to a user ID or phone).
* Access Control: The dashboard page should check for an active user session. If not logged in, it redirects to the Login page. Logged-in users should only see shipments that belong to them (e.g., shipments.user_id = current_user_id).
* Dashboard Layout:
* A welcome message or header like “Hello, [Full Name]! Here are your shipments:” at the top.
* A table listing all shipments for that user. Key columns might include: Tracking Number, Status, CBM (cubic meters volume), Total Cartons, Total Weight (perhaps differentiate net weight vs gross weight (GW) if both are stored), Total Amount (if provided, possibly the shipping cost or value), and maybe origin/destination or dates.
* Each row may have an action to view more details, especially if there are more fields (like pickup date, delivery date, product description). This could either be a clickable row or an explicit “View” button. Alternatively, the table can be scrollable with many columns if the data is not too wide for average screens.
* Filtering and Search: At the top of the dashboard or above the table, provide a search bar or filters so the user can quickly find a specific shipment if they have many.
* The search/filter can be a simple JavaScript filter that matches text in the table (e.g., by tracking number or status) dynamically. This is feasible since a single user likely won’t have an extremely large number of shipments to require server-side filtering.
* Optionally, include dropdown filters for Status (e.g., All, En Route, Delivered, etc.), so the user can view only shipments of a certain status.
* Shipment Details: If the user clicks to view a specific shipment in detail, show a page or modal with full information: all fields from the shipments table, and possibly a history of status updates (pulled from the shipment_scrapes table or logs). For example, show the timeline of statuses if available (“2025-08-01: Left Shanghai port; 2025-08-10: Arrived Beirut Port; …”). This can be presented in a chronological list or table.
* If implementing as a separate page (e.g., shipment.php?id=X), ensure again the user can only access their own shipment (validate that the shipment’s user_id matches the logged-in user, otherwise deny access).
* Design: The dashboard should keep the futuristic theme but also be very clear and business-like (it’s essentially a data page). Use a consistent table style with alternating row colors or subtle lines. Highlight the status with color or icons (e.g., a green check icon for delivered, a yellow hourglass for in transit, etc., along with text).
* For mobile view, the table may need to be converted to a stacked list (each shipment becomes a card with rows of fields) or a horizontally scrollable table. Each shipment card could, for example, show the most important info (Tracking, status, maybe a summary of weight/volume) and the user can tap to expand more details.
* User Options: Include a logout button/link in the dashboard (e.g., top-right of the page or in a user menu) so the client can securely exit their session, especially if on a public device. Logging out simply destroys the session.
* Navigation: Once logged in, the main site navigation can change the “Login” link to something like “My Dashboard” (or show the user’s name) and include a logout link. This way, users can navigate between the dashboard and other pages easily.
Admin Panel
The admin interface allows Salameh Cargo staff to manage users and shipments, and to oversee tracking updates. The admin panel is a separate part of the site, secured behind an admin login (username & password as specified in the admins table). Admin pages are not accessible to normal users. One approach is to host the admin panel under a specific URL path (e.g., /admin/) and protect all its pages with an admin session check. Only users in the admins table with valid credentials can log in.
After logging in, the admin is presented with an admin dashboard page that can have quick stats (like number of shipments in transit, delivered today, etc.) and navigation links to the main admin functions: Add User, Upload Orders, Manage Shipments, and any automated tracking controls. The design of admin panel can be simpler and focus on functionality (doesn’t need the flashy public site design, but should still be responsive and clean). A sidebar or top menu can list the available sections. Ensure to include a logout option for admin as well. Admin pages should also record actions in the logs table for audit trail (see Logs under Database schema).
Admin Login & Access
* Admin Login: A separate login form for admins (username & password). This can be a simple page not linked from the public site (for security by obscurity, the link can be known only to admins). The form should post to an admin authentication script that checks the admins table for a matching username and password hash. Use a strong hashing mechanism (e.g., password_hash() in PHP for storing, and password_verify() for checking). Only on successful login is an $_SESSION['admin_id'] set, after which admin pages can be accessed.
* Session Management: Admin sessions should be distinct from user sessions (e.g., use separate session variables or even separate session cookie parameters if needed) to avoid any confusion. Ideally, keep user and admin login entirely separate.
* Authorization Levels: The admins table includes a role field. You can define roles such as “superadmin”, “manager”, etc., if needed to restrict certain actions. For example, role might be used to allow only certain admins to delete records or add new admins. Implement role-based checks in features if applicable (not strictly required if only one admin role is used, but good for future-proofing).
Add User Manually
* Purpose: Allow admin to create a new user (client) account in the system. This is useful if a new customer is to be added who will have shipments, or to pre-register users who haven’t logged in before.
* Form: An admin page with a form to input user details: Full Name, Email, Phone, Shipping Code, Address, Country, ID Number. All fields correspond to columns in the users table.
* Full Name: (text) The person or company name of the client.
* Email: (text) Email address (optional for login, but useful for contact/records).
* Phone: (text) Contact number in a standardized format (this will be used for OTP login, so it should include country code and be unique in the system). Consider validating format or having separate country code field if needed.
* Shipping Code: (text) An internal code associated with this user. (This might be used to link Excel import records or categorize shipments. For example, some customers might have a short code like “ZAHER” or “BTECH” as seen in file names. This code can be used to quickly identify shipments for that user.)
* Address: (text) The full address of the user (for records or delivery usage).
* Country: (text) Country of the user (could also be part of address, but a separate field can help in filtering or analytics).
* ID Number: (text) Perhaps a government ID or passport number of the client (if needed for shipping paperwork). This is stored for reference but not used in front-end functionality.
* Validation & Storage: The form should validate required fields (at least name, phone) and ensure phone or email isn’t already in use (especially phone, since it’s the login key). On submission, a new entry in users table is created with a new user_id (auto-increment primary key). If using a shipping_code, ensure uniqueness or handle duplicates properly (depends on whether shipping_code is unique per user or could be reused – likely unique per user).
* Success Feedback: After adding, show a success message and perhaps offer to “Add another” or go to “Upload Orders” next. Possibly also display the new user’s details.
Upload Orders (Excel Import)
* Purpose: Bulk-import shipment records from an Excel file. Salameh Cargo often receives shipment details in Excel format (examples provided) – this feature allows the admin to add many shipments quickly without manual data entry.
* Excel Format: The system should accept a specific Excel format. Based on the provided examples (like ZAHER05YW25.xlsx and BTECH01YW25.xlsx), each file appears to contain details of goods for shipments. Likely, each Excel corresponds to a shipment batch for a particular client or container. For simplicity: assume one Excel file = one shipment (or one batch) to be recorded. The Excel contains itemized goods (with columns like description, quantities, CBM, GW, etc.), and possibly summary totals. The import process should extract the relevant totals and info to create a shipment record.
* For example, the Excel might have a total CBM, total cartons, total weight, total gross weight, and total amount for that shipment, which map to the shipments table columns. It may also have a unique shipment code (like “ZAHER05YW25”) that can be used as tracking number or internal code.
* The admin might need to provide or confirm certain info, like which user the shipment belongs to. If the Excel file name or content includes the customer code (e.g., “ZAHER”), the system could auto-match it to a user with shipping_code “ZAHER”. Otherwise, the interface can have the admin select the associated user from a dropdown when uploading.
* Upload Interface: An admin page where they can choose an Excel file (using an HTML file input). Upon submission, the PHP backend will process the file.
* Use a library or method to parse Excel (since no full frameworks, one can use a PHP library like PHPSpreadsheet to read .xlsx files, or require the admin to save as CSV and parse manually. Using PHPSpreadsheet is acceptable as it’s a utility library, not a framework).
* Extract the necessary fields. If the format is consistent, e.g., we know “TOTAL CBM” is a column, we can find that column in the header or by position. Alternatively, if the Excel has a summary section, parse that. We might need to read specific cells if the structure is fixed (for instance, perhaps the last row or a specific cell contains totals).
* If multiple shipments are listed in one file (less likely, but possible if the Excel had multiple sheets or sections for different shipments), handle each accordingly. But from the examples, it seems one file per shipment/client.
* Creating Shipments: For each shipment entry derived from the file, create a new record in shipments table:
* user_id: determined by matching the relevant user (as above).
* tracking_number: this might not be in the Excel explicitly. Possibly, use a combination of the file name or a generated code. If the file name “ZAHER05YW25” is the shipment code, we could use that as the tracking_number or store it as a reference (maybe this is the internal code given to the shipment). The system might also allow admin to input a tracking number if available (e.g., a container number or bill of lading number) after uploading. In absence of a pre-assigned tracking number, generate an internal unique code.
* product_description: possibly a short summary of the goods. Since the Excel lists multiple items, this could be something generic like “Assorted goods” or the admin can manually fill this in if needed. (Alternatively, this field could remain blank or use the first item’s description).
* cbm, cartons, weight, gross_weight, total_amount: take from the Excel’s totals. For instance, sum of CBM column, sum of GW column, etc. According to example headers: “TOTAL CBM” and “TOTAL GW” likely are total cubic meters and total gross weight (in kg). Use those. If the Excel includes a “TOTAL AMOUNT” (perhaps value or cost of goods), fill that as well.
* status: Initially, set status (maybe “En Route” or “Pending” depending on context). If this shipment has just been sent or is on the way, “En Route” is appropriate. Admin can update later if needed.
* origin, destination: Possibly known from context (maybe fixed if Salameh always ships from a specific origin country to Lebanon, or it might be in the Excel or known per batch). The interface could ask the admin to enter origin/destination for the shipment if not in the file. Alternatively, default origin could be China (if these shipments are from China factories) and destination Lebanon, but it should be settable.
* pickup_date, delivery_date: If known, fill them. Likely at import time, these are not known yet (especially delivery_date). Maybe the pickup or departure date is known (if goods left origin on a certain date). If not provided, these can be left NULL initially and updated later.
* created_at: set to current timestamp.
* Feedback: After processing, list the shipments added (or any errors if a file was misformatted). Ensure to handle errors gracefully (e.g., file not readable, missing required fields). Possibly allow a preview before final import, especially if multiple shipments are being imported at once.
* Example Workflow: Admin selects ZAHER05YW25.xlsx and uploads. The system detects maybe “ZAHER” in filename, finds user Zaher (or admin selects Zaher from a dropdown). It parses totals say: CBM=1.2, Cartons=10, GW=200kg, Amount=$5000. It then creates a shipment with those values, status “En Route”, assigns it to Zaher’s user_id, and perhaps sets tracking_number = “ZAHER05YW25” initially as a placeholder code. Later the admin can update the actual tracking number (container or BL number) once known via Shipment Management.
* Security: Only allow admins to access this feature. Also, consider file security – ensure the upload directory is protected or use PHP to read data without saving file permanently. Limit the file size and type (only .xlsx or .csv).
Shipment Management
* Purpose: A master list of all shipments in the system, with options to search, filter, view, and update shipments. This is the core management interface for the cargo records.
* Shipments List View: This admin page displays a table of shipments (likely paginated if there are many). Columns should include key info to identify and manage shipments:
* Tracking Number (or internal Shipment Code)
* Recipient Name (linking to user)
* Phone or User (maybe show the user’s phone or name for quick reference)
* Origin -> Destination
* Status (current status)
* Important metrics like CBM, Cartons, Weight (could be shown in the list or viewable on detail)
* Pickup Date (if set)
* Delivery Date (if delivered)
* Filtering/Searching: Provide controls to filter shipments by status (e.g., a dropdown: All, En Route, Delivered, etc.), by origin/destination, or by date range (e.g., shipments sent in last month). A text search box should allow finding shipments by tracking number, user name, phone, or any other identifier. The search can be implemented server-side (the form submits and the query filters results) for accuracy and to handle large data sets.
* Actions: Each shipment row could have action buttons or links:
* View/Details: Opens a detailed view of the shipment (similar to what the user would see, but possibly with more internal info like full scrape history, and editable fields).
* Edit/Update: Allows admin to modify the shipment record. Specifically, admin should be able to update the status manually (for example, mark a shipment as “Delivered” once it has been delivered, if the automation hasn’t caught it or for offline shipments). They might also edit other fields if needed (e.g., adjust weight or amount if a correction is needed, or add a missing tracking number).
* Delete: Possibly allow deletion of a shipment record if it was entered by mistake. (If implementing, be careful to maybe require confirmation and also remove associated shipment_scrapes and logs or mark them as deleted). Deletion can be restricted to certain admin roles or not provided at all if not necessary.
* Status Updates: When an admin manually updates a status (or any field), the system should log this action in the logs table (e.g., action_type “update_status”, user_id_or_admin_id = that admin’s id, related_shipment_id, timestamp). This keeps an audit trail. The shipments.status field should reflect the latest status (whether set by automation or manual).
* Detail View for Admin: Clicking on a shipment (or a separate page) shows full details. Admin can see all fields, and also a section for Status History – the data from shipment_scrapes table for that shipment. For example, it might show entries like: “Source: CMA CGM – Status: Loaded on vessel (raw: ‘Loaded on vessel in Shanghai’) – Time: 2025-07-01 10:00” and then “Source: BCTC – Status: Arrived at Beirut Port (raw: ‘Container discharged at Beirut’) – Time: 2025-08-10 08:00”, etc. This is valuable for the admin to verify and also communicate updates to clients if needed.
* Possibly allow the admin to trigger a fresh scrape for that shipment from here (like a “Refresh Status” button) which will run the scraping function on-demand for that shipment’s tracking number across sources.
* UI & UX: This section is more data-centric. Use a straightforward admin theme or custom CSS that aligns with the public site subtly but focuses on readability (light background for admin is fine if preferred). Highlight statuses (maybe color-code as in user view). Use icons for actions (edit pencil, trash can, etc., with proper labels or tooltips).
* Make sure to handle long lists well, e.g., the table is sortable by clicking column headers (could use JS for client sort or do server queries).
* The interface should be tested with, say, hundreds of shipments to ensure performance (maybe load 50 per page and have pagination controls at bottom).
* Security: Only logged-in admins can access. Each action (edit/delete) should require proper privileges. Use CSRF protection tokens in forms for editing/deleting to avoid cross-site request issues since this is an internal tool but still good practice.
Automated Tracking Integration
* Purpose: Automate fetching of the latest shipment statuses from external tracking sources. This is crucial for providing up-to-date information without requiring manual updates for each shipment. The system will periodically or on-demand retrieve status updates from a list of external websites/APIs and store the results.
* Target Sources: The following external tracking sites are to be integrated (scraped or via API if available):
* WTO Cargo – (Perhaps a regional tracking site or company; will likely need scraping as no known public API)
* CMA CGM – (Major shipping line, provides tracking by container or BL number on their website)
* MSC – (Another major carrier, has tracking webpage)
* ONE (Ocean Network Express) – (Carrier tracking site)
* MAERSK – (Carrier, may have an API but also a tracking page)
* EMC (Evergreen Marine Corp) – (carrier)
* Evergreen – (possibly same as EMC above, or double entry)
* track-trace.com (container) – (Aggregated container tracking for many companies)
* searates.com (container tracking) – (Provides container tracking, possibly via API with key)
* shipsgo.com – (Container tracking service that might require login/API subscription)
* gocomet.com (container-tracking) – (Another aggregator platform)
* findteu.com – (Container tracking aggregator/API)
* marinetraffic.com – (Vessel tracking, and has container tracking API for a fee; could be used if vessel info needed)
* vesselfinder.com – (Vessel tracking site, might not have container info directly, more for ship positions)
* bctc.com.lb – (Beirut Container Terminal Consortium – likely provides status of containers at Beirut Port)
* portdebeyrouth.com – (Port of Beirut official site – might list container discharge or customs status)
* Integration Approach: Because no external frameworks are allowed, integration will be done with raw PHP HTTP requests (e.g., using cURL or file_get_contents) and parsing of HTML responses (or JSON if any API endpoints exist).
* For each shipment, we likely have a tracking identifier (could be a container number, an air waybill, or a bill of lading). Many of the listed sites (CMA CGM, MSC, etc.) track by container number or BL. We need to determine which site to query for a given shipment.
* Automatic Site Selection: If the tracking number is a container number (format e.g., ABCD1234567), one strategy is to use track-trace.com which can auto-detect the shipping line by the container prefix[2][3]. For example, track-trace will forward the request to the appropriate carrier’s tracking if known. We could scrape track-trace’s results page. Alternatively, if the carrier is known (maybe by another field or by prefix logic ourselves), we can directly scrape that carrier’s site.
* For bill of lading numbers or others, some aggregators like track-trace have a separate BL tracking page, and some sites (like CMA CGM) allow BL tracking. If needed, we focus on container tracking since that’s most common for cargo shipments.
* Scraping Method: For each source site, write a PHP function or class to handle tracking queries:
o e.g., scrape_cma_cgm($containerNumber): craft the URL or form submission to CMA CGM’s tracking page (they might require a POST with the number, or a GET request with the number in URL). Retrieve the HTML, then parse for status information (e.g., using DOMDocument or regex to find the element that contains the status text). Each site will have its own HTML structure.
o Similarly, scrape_bctc($containerNumber): likely BCTC has a page where you input container ID to get status at Beirut port. Scrape the result (e.g., it might show if container is discharged, available, cleared, etc.).
o Use error handling: if a site is down or format changed, the scraper should not crash the whole system. Maybe set a timeout for requests and handle exceptions.
* Data Storage: Whenever a scrape is performed, whether via cron or user action, store the result in the shipment_scrapes table:
o shipment_id: link to the shipment.
o source_site: short identifier for source (e.g., “CMA CGM”, “BCTC”).
o status: a normalized status text (e.g., “In Transit”, “Arrived at Port”, “Delivered”). The scraper function can map the raw text into one of our standard statuses if possible. For instance, if CMA CGM’s site says “Gate Out Full – Delivered”, we might map that to “Delivered”. If not sure, we can just repeat the raw text here as well.
o status_raw: the exact raw status or additional info pulled (e.g., full sentence or location info). This helps in debugging or displaying detailed info if needed.
o scrape_time: timestamp of when this scrape was done.
o (If more info is available, like location or timestamp of the event, those might be appended into status_raw or we could extend the table, but for now we keep it simple.)
* After storing, also update the main shipments.status if the fetched status is a significant update (e.g., if different from current and presumably a later stage). For example, if currently “En Route” and scrape finds a status indicating delivered, update shipments.status = “Delivered”. This keeps the main table in sync with latest info. If multiple sources are scraped, we might prioritize one (e.g., port status might confirm final delivery). We should decide a hierarchy or logic: Possibly trust carrier info for in-transit updates, and port/local info for arrival and delivery.
* Cron Job / Scheduler: To keep statuses updated automatically, set up a cron job (on Linux server) or Windows Task Scheduler (on XAMPP/Windows)[4] to run a PHP script at regular intervals (e.g., daily, or twice a day). This script will:
* Connect to the database, find all shipments that are not delivered yet (e.g., status != “Delivered” or where delivery_date is NULL).
* For each, attempt to scrape from one or more sources. Possibly maintain which source was last successful or rotate through sources. For example, try track-trace first (which covers many carriers), then if needed check local sites (BCTC, portdebeyrouth) if the shipment is nearing arrival.
* Update the database with any new info as described. Possibly send notifications if needed (not required, but could email admin if something arrived).
* Log the actions (maybe insert entries in logs table for these automated updates as well, with a distinct action_type like “cron_update”).
* The cron frequency can be daily since container status doesn’t change hour-by-hour in most cases, but this can be adjusted.
* On-Demand Update: In addition to the scheduled job, allow the admin (and possibly the user) to trigger an update:
* Admin side: A “Refresh” button on a shipment detail (or a global “Update All Now” in the admin dashboard) can manually run the scrape for that shipment or all. This is useful if a client calls and asks for an update – admin can click refresh and get the latest immediately instead of waiting for the next cron run.
* User side: We could automatically trigger a live check when a user searches on the Track page or views their dashboard, to ensure they see current data. For example, if a user is viewing their shipment detail and the last update was 20 hours ago, the system might behind the scenes fetch a fresh update from the source and then refresh the page with new info. This should be done carefully to avoid slowing down the user experience (could show a “checking latest status…” spinner). If implemented, it should still store the new result in DB.
* Fallback to Database Backup: If external tracking sites are unreachable or return no data (which can happen due to network issues or site changes), the system will fall back to the last known status stored in the database. Essentially, the shipments table and shipment_scrapes act as a “cache” of tracking information. The daily cron ensures the cache is updated. But if, say, at the moment of a user query the live fetch fails, we simply show whatever is in our database (which at worst is yesterday’s information). This ensures the user always sees something and the system doesn’t break.
* Also, if an Excel daily update or some offline process is in place (e.g., maybe Salameh Cargo receives daily status reports and imports them), the design can accommodate that — but given we have scraping, that might not be necessary.
* Extensibility: The scraping functionality should be modular, as new sources might be added or some removed. For instance, if a new shipping line is used, we can add a new scraper function. If an official API becomes available, we can replace scraping with API calls (e.g., some services like Searates or FindTEU offer unified API – if budget allows, the system could integrate with those via an API key to get structured data instead of scraping HTML). The architecture accounts for this by separating the data retrieval (scraping/API) from the display.
* Note: Scraping external websites can be brittle (HTML structure changes) and might have legal or bot-protection issues. Using APIs or official channels is preferable where possible. For example, if CMA CGM offers an API token for tracking, using that would be more reliable than scraping their site. However, the design here assumes mostly scraping due to the no-framework, quick solution approach. Admin should be aware to adjust the scraper code if sites change. Logging errors from scraping attempts (to the logs table or a file) would help in maintenance.
Database Schema
The MySQL database consists of several tables to store user info, shipments, tracking updates, admin credentials, and activity logs. Below is the design for each table, including columns and their purpose:
1. users – Stores client (shipper/receiver) information. Each user corresponds to a person or company that can log in via phone/OTP to view shipments.
2. user_id – INT, primary key, auto-increment: Unique identifier for each user.
3. full_name – VARCHAR(255): The full name of the user (individual or business).
4. email – VARCHAR(255): Email address of the user (optional, for contact or future features).
5. phone – VARCHAR(50): Phone number of the user (in international format). This should be unique, as it’s used for login (OTP sending) and identifying the user’s shipments.
6. shipping_code – VARCHAR(100): An internal code associated with this user. This could be a short identifier used in shipment references or Excel files. (e.g., “ZAHER” or “BTECH” as seen in examples). If not used, it can be NULL, but if provided it should be unique or at least meaningful per user.
7. address – VARCHAR(255): Physical address of the user. Could be used for delivery or records.
8. country – VARCHAR(100): Country of the user (e.g., “Lebanon”).
9. ID_number – VARCHAR(100): Identification number (such as passport, ID card, or business registration number). Provided for record-keeping.
10. Indexes & Constraints:
o Primary Key on user_id.
o Unique index on phone (to ensure no two users share the same phone). Possibly also unique on email if needed.
11. shipments – Stores shipment details. Each record represents a shipment or consignment being tracked. This is linked to a user (the receiver or client who will track it).
12. shipment_id – INT, primary key, auto-increment: Unique ID for the shipment record.
13. user_id – INT, foreign key referencing users(user_id): The owner/receiver of this shipment. This links the shipment to the user who can see it in their dashboard. Ensure referential integrity (if a user is deleted, either cascade delete their shipments or disallow deletion if shipments exist; probably better to keep shipments, so maybe do NOT cascade).
14. tracking_number – VARCHAR(100): The primary tracking identifier for the shipment. This could be a container number (e.g., “MSKU1234567”), an air waybill, a bill of lading number, or an internal reference code. This is what users might input to track, and what the system uses for external lookups. It should be unique if possible (at least unique per active shipment to avoid confusion).
15. product_description – TEXT: Description of the goods or shipment content. This could be a short summary (e.g., “Electronics and appliances” or “Clothing items”) or details. If multiple items, this might list key items or be generic if details are elsewhere (like in an attached doc).
16. cbm – DECIMAL(10,2): Total volume of the shipment in cubic meters (CBM). Decimal to allow fractional CBM.
17. cartons – INT: Total number of cartons/boxes in the shipment.
18. weight – DECIMAL(10,2): Total net weight of the shipment (in kilograms, presumably).
19. gross_weight – DECIMAL(10,2): Total gross weight (including packaging) in kg. Gross weight might be slightly higher than net weight.
20. total_amount – DECIMAL(10,2): Total invoice amount or value of the shipment (could be in USD or another currency, depending on context). This might represent the cost of goods or shipping charges. (It’s a numeric field; currency can be assumed or add a currency field if needed).
21. status – VARCHAR(50): Current status of the shipment in simplified form. Examples: “En Route”, “At Origin”, “In Transit”, “Arrived at Port”, “Delivered”, “On Hold”, etc. This field is updated either by admin or automated tracking. It’s what shows up in user dashboards as the latest status.
22. origin – VARCHAR(100): Origin location of the shipment (e.g., “Shanghai, China”). Possibly just country or city+country.
23. destination – VARCHAR(100): Destination location (e.g., “Beirut, Lebanon”). For Salameh Cargo presumably many will have destination Lebanon but include city if multiple destinations.
24. pickup_date – DATE/DATETIME: Date when the shipment was picked up or departed origin. If unknown, can be NULL.
25. delivery_date – DATE/DATETIME: Date when the shipment was delivered to final destination. Remains NULL until delivery actually happens (then set either by admin on confirmation or possibly by automation if we scrape a “delivered” status).
26. created_at – DATETIME: Timestamp when the shipment record was created (e.g., when imported or added). Default to CURRENT_TIMESTAMP.
27. Indexes & Constraints:
o Primary Key on shipment_id.
o Index on user_id (for faster join/filter by user).
o You may index tracking_number as well, since searches by tracking number are frequent.
o user_id foreign key references users. Ensure on delete behavior (perhaps set NULL on user deletion or restrict).
28. shipment_scrapes – Stores data from each external tracking scrape attempt. This table can grow large, so consider pruning old entries if necessary, but it provides a history of what was fetched from where and when.
29. scrape_id – INT, primary key, auto-increment: Unique ID for each scrape record.
30. shipment_id – INT, foreign key referencing shipments(shipment_id): The shipment this record is about.
31. source_site – VARCHAR(50): Which source the data came from. e.g., “CMA CGM”, “BCTC”, “MSC”, “track-trace”, etc. This is set by the scraper to identify origin.
32. status – VARCHAR(100): The status extracted/parsed in a normalized form. Ideally a short standard phrase like “In Transit”, “Delivered”, “Arrived at Port”. This might be manually mapped from the raw text. If no mapping is done, it could be same as raw or a truncated version of it.
33. status_raw – TEXT: The raw status (and possibly additional info) as obtained from the source. This could include location or date info embedded in text. For example, raw might be “Arrived at BEIRUT PORT on 10-AUG-2025 08:00”.
34. scrape_time – DATETIME: When this scrape was performed. Default to CURRENT_TIMESTAMP on insert.
35. Indexes & Constraints:
o Primary Key on scrape_id.
o Index on shipment_id (to quickly retrieve all scrapes for a shipment).
o Foreign key on shipment_id referencing shipments. Likely use ON DELETE CASCADE here – if a shipment is deleted, its scrapes can be deleted too to avoid orphan records.
36. admins – Stores admin user credentials and roles for accessing the admin panel.
37. admin_id – INT, primary key, auto-increment: Unique ID for each admin.
38. username – VARCHAR(100): Login username for admin (should be unique).
39. password_hash – VARCHAR(255): Hashed password for the admin. Use a secure hash (e.g., PHP’s password_hash which typically produces a 60-character hash for Bcrypt, or longer for Argon2). Never store plain passwords.
40. role – VARCHAR(50): Role of the admin, e.g., “superadmin”, “manager”, “clerk”, etc., to differentiate permissions. This can be used in the app logic to restrict access to certain features. For example, role “manager” might not have rights to add new admins, etc. If multiple roles are not needed initially, can default all to e.g. “admin”.
41. Use: This table is checked during admin login. There likely will be only a few entries (for each staff member who needs backend access).
42. Indexes:
o Primary key on admin_id.
o Unique index on username.
43. logs – A general activity log table to record important actions in the system (by both admins and possibly user-triggered events). This helps with auditing and debugging.
44. log_id – INT, primary key, auto-increment: Unique ID for each log entry.
45. action_type – VARCHAR(50): Type of action or event. Examples: “login_success”, “login_failure”, “add_user”, “update_shipment”, “status_scrape”, “manual_status_update”, etc. Define a consistent set of action keywords.
46. user_id_or_admin_id – INT: The ID of the user or admin who performed the action. This could reference either a user or an admin, depending on context. To differentiate, one approach is to use positive IDs for users and negative IDs for admins (or vice versa), or have another column for role. Alternatively, we could split this into two fields (user_id and admin_id) where one is NULL for a given log. But to keep it simple, we use one field: e.g., if an admin with id 5 did something, put admin’s id as negative (-5) to indicate admin, whereas user id 5 would just be 5. This interpretation should be clearly documented in the code.
47. related_shipment_id – INT: If the action is related to a specific shipment (like an update to a shipment or a tracking event), put the shipment id. Otherwise, it can be NULL or 0. For example, login actions might not have a shipment id.
48. timestamp – DATETIME: When the action happened. Default CURRENT_TIMESTAMP.
49. details (optional) – TEXT: You might want a details or remarks field to store additional info (e.g., “Status changed from X to Y”, or “Failed login attempt with phone 12345”). This field wasn’t listed in original requirements, but could be very useful for a truly bulletproof log system. If not, the combination of action_type and related ids may suffice.
50. Indexes:
o Primary key on log_id.
o Index on user_id_or_admin_id (so we can query actions by a certain actor).
o Index on related_shipment_id (to find all logs for a shipment, maybe to trace its history).
Relationships & Notable Constraints:
- users to shipments: One-to-many. One user can have many shipments. Enforce that user_id in shipments must exist in users (foreign key). Consider on-delete: probably we do not want to delete shipments if a user is deleted by accident (we might instead orphan them or prevent user deletion). Since a user likely wouldn’t be deleted unless no longer a client, and even then we might keep their shipments history, it’s safer to disallow user deletion or require manual cleanup.
- shipments to shipment_scrapes: One-to-many. If a shipment is removed, its scrapes should be removed (on delete cascade) to keep DB clean.
- admins is standalone except referenced in logs implicitly.
- logs references users/admins in a polymorphic way (as discussed). Alternatively, we can split logs into user_logs and admin_logs, but one table is fine with a clear convention.
The database should be created with appropriate data types (the ones mentioned are suggestions; adjust lengths as needed, e.g., phone may need 15-20 chars). Use InnoDB engine for referential integrity. Initial test data can be inserted (like an admin account, some users, shipments) to verify everything links correctly.
User Interface Structure & Navigation
This section summarizes how the different pages and components come together and notes on making the UI intuitive and consistent:
* Global Navigation (Public): The public-facing site (Home, Track, About, Contact, Login) has a top navigation bar. This bar shows the company logo on the left and menu links on the right (on desktop). On mobile, it collapses to a menu icon. The links available to non-logged-in users are: Home, Track Your Shipment, About Us, Contact Us, and Login. The “Track Your Shipment” link goes to the dedicated tracking page (even though Home also has a search, the link is provided for clarity).
* When a user logs in, the navigation should change the “Login” link to something like “Dashboard” (and possibly display the user’s name or a user icon). Also, a “Logout” link should appear (could be in a dropdown under the name/icon or simply another item). The logged-in user should still be able to visit the other pages (Home, About, etc.) if they want.
* The design of the nav should match the futuristic theme – perhaps a semi-transparent dark bar or a sleek solid color, with hover effects on links. It should remain fixed at top during scroll for easy access (optional).
* Public Pages Layout: Each page (Home, Track, About, Contact, Login) should have a consistent header and footer. The footer can have basic info (© 2025 Salameh Cargo, maybe some social media icons or “Powered by ...” if needed). The content area of each page should be structured with responsive grids or sections as appropriate: for instance, About Us may use multiple sections with background colors, etc., whereas Track page is more form-centric. Use CSS media queries to adjust font sizes, images, and layouts for smaller screens.
* Dashboard Navigation (User): Within the user’s Dashboard pages, if multiple sub-pages existed (like list of shipments vs profile settings), we might include a sidebar or secondary menu. In this case, the main need is the shipments list and possibly a detail view. We can simply include a back link from detail to the list, or use a single page with the list and a modal for details. For simplicity: one page that lists shipments, and clicking a shipment either expands it in-place or navigates to a new page. A breadcrumb or header should indicate where the user is (“My Shipments”).
* The main site navigation is still visible, but we highlight Dashboard in it. Alternatively, the dashboard can be a more app-like full-width page. Either approach is fine as long as the user isn’t confused between public pages and their account section.
* Admin Panel Navigation: The admin area should have its own navigation separate from the public site. Typically, we do not mix public nav in admin pages. For example, an admin landing page might have a sidebar menu with: Dashboard, Add User, Upload Orders, Shipments, (and possibly Admin Users management if needed). Or a top menu if preferred. Given XAMPP and simplicity, a sidebar is a straightforward choice for a desktop-oriented admin interface; on mobile, that can collapse to a menu.
* Admin pages might not need to be accessible on tiny screens often, but making them responsive is still good (the staff might check on a tablet or phone). Use a simple grid or stack layout for forms.
* Each admin section (Add User, Upload, Manage Shipments) corresponds to pages we described. The admin should be able to switch between them easily. The “Dashboard” could show summary stats (like number of shipments in each status, recent activity logs, etc., though that’s optional).
* Also include a link to “Logs” or “Activity” if the logs are to be reviewed (this wasn’t specified, but an admin viewing logs could be useful for debugging). If included, create a page showing recent log entries with filters. If not, logs can remain a database-only thing unless needed.
* Visual Theme: The term futuristic suggests using a modern design language: perhaps dark mode with neon or bright highlights (like electric blue or green for accents), sleek fonts (sans-serif, maybe a thin font for a sci-fi look, but ensure readability). Small touches like glowing effects on focus, or an animated background (like moving digital world map or network lines) can add to the feel. However, balance aesthetics with performance—don’t overload with heavy animations that slow the page.
* Buttons and inputs can have a modern flat design with subtle gradients or shadows. Use consistent styling for all forms (user and admin).
* Icons (use icon libraries or SVGs) can help: e.g., a search icon in the tracking bar, icons for contact (phone, email, WhatsApp), and status icons (delivered, transit, etc.). Since no frameworks, you can include an icon set via CSS (like Font Awesome CDN) for convenience.
* Error Handling and Messages: All user inputs (search queries, login, etc.) should have validation and user-friendly error messages. E.g., “No shipments found for the provided query” on the Track page if nothing matches, or “Invalid OTP, please try again” on login if wrong code. Use JavaScript for immediate validation feedback where appropriate (like checking phone number format on login). Error messages should be styled to stand out (maybe red text or a modal alert).
* Similarly, admin actions should confirm success or failure: e.g., “User added successfully” or “Failed to import Excel – unrecognized format.” Provide enough info for the admin to correct issues (like “No user found matching the shipping code in file; please create the user first or check the code.”).
* Security in UI: Ensure that sensitive actions are protected. For example, the admin delete shipment (if implemented) might require a confirmation dialog (“Are you sure you want to delete shipment X? This action cannot be undone.”). Logging out should require a deliberate click. The OTP fields and other critical interactions should be over HTTPS (in deployment) to protect data.
By structuring the UI in this way, we ensure a seamless experience for both clients and admins, each seeing only what they need in a clean interface.
Technical & Architectural Notes (Developer Guidance)
This section provides additional notes and best practices for developers implementing the system to ensure it is robust, maintainable, and secure:
* Technology Stack: The system uses PHP (should run on XAMPP which typically includes PHP and Apache), with MySQL as the database. All code is custom without frameworks, meaning you’ll write your own routing or use simple PHP pages, your own SQL queries (use PDO or MySQLi with prepared statements to prevent SQL injection), and your own frontend components (no React/Angular, etc.). Vanilla JS for any interactive needs on frontend.
* Ensure PHP is configured properly on XAMPP (enable needed extensions for cURL, OpenSSL for HTTPS requests to external sites, etc.).
* The solution should be portable; configuration (like DB credentials, site base URL) can be stored in a single config file for easy changes.
* File Structure: Organize the files logically: for example, have separate directories for public site and admin site, or at least prefix admin pages with admin_*.php. Keep reusable components like header, footer, DB connection in include files. Possibly structure as follows:
* /index.php (Home), /track.php, /about.php, /contact.php, /login.php, /dashboard.php for user side.
* /admin/login.php, /admin/dashboard.php, /admin/add_user.php, /admin/upload_orders.php, /admin/shipments.php, etc., for admin.
* /includes/db.php for database connection, /includes/header.php and footer for common HTML, etc.
* A separate script for OTP sending, e.g., /login_otp_process.php to handle form submission (or handle within login.php with conditional logic). Similarly, separate processing scripts for form submissions (or single entry points handling via $_POST).
* A cron script file e.g. /cron/update_shipments.php which can be scheduled to run.
* WhatsApp OTP Implementation: As mentioned, using an external service is necessary because WhatsApp can’t be sent directly from PHP without an API.
* Twilio API: Twilio’s Verify API for WhatsApp is a straightforward option[1]. You would need Twilio account credentials and to set up a WhatsApp sender (Twilio provides a sandbox or you register a WhatsApp Business number). The PHP code would use Twilio’s PHP SDK or a simple HTTP POST to Twilio’s API to send the OTP template message. Alternatively, Twilio Programmable Messaging API can send a custom WhatsApp message if you prefer to craft the message and handle code verification yourself.
* WhatsApp Business Cloud API: Facebook/Meta provides a cloud API where you can send template messages (like OTPs) to users who have opted in. This is another route but also requires account setup and is a bit more complex to start with.
* For the scope here, Twilio is easier to integrate. Ensure to secure the API credentials (don’t hardcode in a public file). Also, handle the asynchronous nature: typically sending message via API returns immediately with success/failed, and the message arrives to user in a few seconds. Just inform user to check WhatsApp.
* The OTP generation can be done via PHP’s random_int or similar secure random generator. Example: $code = strval(random_int(100000, 999999));. Store it in $_SESSION along with the phone or in a temp table. If using Twilio Verify, Twilio can handle generating and verifying OTP codes for you, simplifying your code (you just call verify with the code user provides).
* Testing: In a dev environment without actual WhatsApp API, you might bypass sending and just log/display the OTP for testing. But on production, ensure it truly sends.
* Scraping & External Requests:
* Use PHP cURL for robust HTTP requests. Set appropriate options like timeouts (e.g., 10 seconds) so a hang doesn’t stall your script. Some tracking sites may use HTTPS and have certificates – ensure SSL verification is handled (cURL typically does, but in some XAMPP setups you might need to update CA bundle).
* Many of these sites might have query forms. For example, track-trace might require just a GET with the container number in the URL, or it might be a form POST. Investigate by manually querying or reading their HTML. You might find easier to use track-trace’s direct link: e.g., https://www.track-trace.com/container?number=MSKU1234567 might directly show result. If not, you might simulate form submission.
* Parsing HTML: Use DOMDocument or SimpleXML if the HTML is well-formed. If not, a library like Simple HTML DOM (a single PHP file include) can help parse ill-formed HTML easily. Without external libs, DOMDocument is your friend (loadHTML, then getElementById or getElementsByTagName to find the relevant info). You’ll need to find patterns, like maybe the status is in a <div class="status">Delivered</div> or in a table cell. Each site will differ. You can maintain these parsing rules per source.
* Rate limiting / courtesy: If cron hits many external sites, consider spacing requests or doing it in batches to avoid hitting any single service too frequently. Track-trace for example might block if too many requests quickly. For a moderate number of shipments, this is usually fine.
* Error handling: If a scrape fails (e.g., network error or the returned HTML doesn’t contain what we expect), log it. Possibly set an error status or increment a retry count. If a particular shipment consistently fails to update, admin should be alerted or it should be flagged for manual checking.
* Data accuracy: Different sources might give overlapping info. It’s wise to trust primary sources (like the shipping line’s official site) for transit info, and local sources (port site) for arrival info. The system could update status in stages: e.g., when portdebeyrouth shows container received, that could trigger marking it as “Arrived at Destination” or “Ready for pickup”. If delivered to customer, admin likely has to confirm and update “Delivered” status manually (unless the system is tied into a delivery confirmation process).
* Cron Setup: Since XAMPP is on Windows, a typical cron tab isn’t available. You would use Windows Task Scheduler[4] to call the PHP script at intervals. For example, schedule php.exe C:\xampp\htdocs\cron\update_shipments.php daily at 6 AM. Ensure the script can run stand-alone (include the config to connect to DB, etc.). Test it. Alternatively, if deployed on a Linux server later, you can use crontab. The system design is the same, just the scheduling mechanism differs. Document this for the deployment.
* Security Considerations:
* SQL Injection: Use prepared statements for all database operations. For example, when searching shipments by user input (tracking number, name, etc.), never directly concatenate strings into SQL. Use parameter binding. Also, apply input filtering where appropriate (e.g., tracking numbers might have a specific format, phone is digits, etc.).
* XSS: Escape output that comes from the database when displaying on pages, especially anything users might input (though in this system, users don’t input too much content except search queries or login phone which aren’t stored long-term). Use htmlspecialchars() in PHP or equivalent when echoing data into HTML to avoid HTML injection.
* Authentication: Ensure session cookies are marked HTTPOnly and Secure (if HTTPS). Use session_regenerate_id on login to prevent session fixation. Also, implement a reasonable session timeout (e.g., log out users after 30 minutes of inactivity, especially for admin).
* Password storage: Admin passwords must be hashed (as noted). For OTP for users, since it’s single-use, it’s okay to store in plain or hashed temporarily. If using Twilio Verify, you don’t store it at all, Twilio handles verification.
* File Uploads: The Excel upload should be secured. Only allow logged-in admins to hit that endpoint. If saving the file on server to parse, store it outside web root or ensure it cannot be accessed via URL. Delete it after processing. Validate that it’s a real Excel (check the mime or extension) to prevent someone uploading a PHP file to exploit. Since no public user upload is allowed, risk is low, but still follow best practices.
* Access Control: Double-check that pages enforce permissions: e.g., an admin-only page should check isset($_SESSION['admin_id']) and perhaps the role; a user dashboard should check $_SESSION['user_id'] and also verify the data pulled belongs to that user. These checks are critical to prevent data leakage between accounts.
* Logs and Auditing: The logs table can be used to monitor any suspicious activity. For instance, if someone tries a lot of OTP requests or if an admin updates a status, it’s recorded. While not a direct security feature, it helps in forensic analysis if something goes wrong.
* Performance and Scalability:
* The design as given is suitable for a moderate number of users and shipments. MySQL can handle thousands of records easily. If it grows to hundreds of thousands of shipments, more advanced considerations (like indexing more fields, archiving old data, optimizing the scraping routine) would come in.
* The most heavy operations here could be the web scraping – which is I/O bound and depends on external sites. Doing too many in parallel could be slow. If needed, consider staggering the cron or using asynchronous calls. But likely this is manageable given typical shipment volumes for a single company.
* The UI is mostly simple pages; ensure to optimize images (if any on home/about) and minify CSS/JS for faster loads. XAMPP dev environment might not reflect real network conditions, so test with some latency in mind.
* Restartability: The system should be installable from scratch using the info here. This means:
* Provide an SQL script to create the database tables with the schema above. Include perhaps the creation of an initial admin user (admin/hashedpassword) so the developer can immediately log in.
* Ensure that configuration is easy to update (DB credentials, Twilio API keys, etc. all in one config file). Document any such needed configurations.
* If migrating from an existing system (like the WordPress WPCargo plugin previously used), provide scripts to import those records into this new schema as needed. This wasn’t explicitly asked, but since we saw references, it might be something to consider externally. The design here is self-contained though.
* Future Enhancements: While out of scope for now, the design allows future improvements like:
* Email or WhatsApp notifications to users when status changes (for example, “Your shipment has arrived at Beirut port”). This can be built using the scraping data (trigger an alert when a new scrape entry is added that meets criteria).
* More granular user roles or multiple user accounts (if a company client wants multiple logins, we might then link users to companies, etc.).
* A more advanced tracking UI with maps or progress bars. For instance, showing a progress bar of journey stages (Ordered -> In Transit -> At Port -> Out for Delivery -> Delivered). This could be derived from status.
* Integration with a barcode/QR scanning for tracking (the screenshot we saw had a QR code for shipments, presumably encoding the tracking URL). We could generate QR codes for each tracking number on shipment creation (using a PHP QR library) so that documents can include them. Not required, but worth noting.
* Multi-language support if needed, since in Lebanon both English and Arabic (or French) might be used. Currently, we assume English UI.
By following this design specification, developers can confidently build the Salameh Cargo tracking system from scratch. The system will provide a smooth experience for clients tracking their shipments and a powerful tool for admins to manage and update shipment information. Each component has been detailed for clarity, ensuring the implementation can proceed without guesswork. The end result will be a secure, modern, and reliable cargo tracking website, tailored to Salameh Cargo’s needs and ready for future expansion.
